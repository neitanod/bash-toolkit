#!/bin/bash
_bash_toolkit_is_sourced() {
  # Comprueba si el script está siendo ejecutado en el contexto de la shell actual (sourced)
	# o si está siendo ejecutado en una subshell (indirectamente a través de una subllamada)
	[[ "${BASH_SOURCE[0]}" != "${0}" ]]
}

if ! _bash_toolkit_is_sourced; then
	cd "$(dirname "$0")"
	source ./lib/colors.sh
	cat <<EOF
${RED}ERROR:${NORMAL}
${0}
${RED}must be sourced, not just run.${NORMAL}

    ./_autocomplete          ${RED}Wrong!${NORMAL}

    source ./_autocomplete   ${GREEN}Correct${NORMAL}

    . ./_autocomplete        ${GREEN}Correct${NORMAL}
EOF
	exit 1
fi

curdir=$(pwd)
cd "$(dirname "$0")"
TOOLKIT_DIR="$(pwd)"

cd "$(dirname "$1")"
ENV_VAR_NAME_SCRIPTS="MY_SCRIPTS"

#SCRIPTS_DIR="$(dirname $(pwd))"
SCRIPTS_DIR="$(pwd)"

TOOLKIT_ENTRY_POINT=""
TOOLKIT_ENTRY_POINT_2=""

#source "../config"  # This can override ENV_VAR_NAME_SCRIPTS
source $1

SETVAR="export ${ENV_VAR_NAME_SCRIPTS}="${SCRIPTS_DIR}""; eval $SETVAR
SETVAR="export _${TOOLKIT_UNIQUE_SLUG}__SCRIPTS_DIR=\"${SCRIPTS_DIR}\""; eval $SETVAR
SETVAR="export _${TOOLKIT_UNIQUE_SLUG}__TOOLKIT_PREFIX=\"${TOOLKIT_PREFIX}\""; eval $SETVAR

cd $curdir

_bash_toolkit_count_positional_args() {
  local count=0
  for arg in "${COMP_WORDS[@]:1}"; do
    if [[ ! "$arg" =~ ^- ]]; then
      ((count++))
    fi
  done
  ((count--))
  echo "$count"
}

_bash_toolkit_process_options() {
    local cur="${COMP_WORDS[COMP_CWORD]}"  # Lo que está escribiendo el usuario
    local opts
    local matches=()

    # Capturar el output de tu script que devuelve las opciones
    opts=$("$1")  # Llamamos al comando (pasado como argumento)

    # Procesar cada línea de las opciones
    for line in $opts; do
        local key="${line%%[[:space:]]*}"  # Extraer la opción (la primera palabra antes del espacio/tab)
        local desc="${line#*$key}"         # Extraer la descripción (todo lo que sigue después de la opción)

        # Filtrar las opciones que coinciden con lo que el usuario ha escrito
        if [[ "$key" == "$cur"* ]]; then
            matches+=("${key}$'\t${desc}")  # Formato con tabulación
        fi
    done

    # Usar compgen para generar las opciones de autocompletado
    compgen -W "${matches[*]}" -- "$cur"
}

_bash_toolkit_autocomplete() {
  ( echo "===" >> /tmp/slg_autocomplete.log ) 2> /dev/null
  ( echo "$@" >> /tmp/slg_autocomplete.log ) 2> /dev/null

	SETVAR="SCRIPTS_DIR=\${_${SLUG}__SCRIPTS_DIR}"; eval "$SETVAR"
  SETVAR="TOOLKIT_PREFIX=\${_${SLUG}__TOOLKIT_PREFIX}"; eval "$SETVAR"
 

	local cur prev opts
	COMPREPLY=()
	cur="${COMP_WORDS[COMP_CWORD]}"
	prev="${COMP_WORDS[COMP_CWORD - 1]}"

	opts=$(ls $SCRIPTS_DIR | grep '^'$TOOLKIT_PREFIX | sed 's/^'$TOOLKIT_PREFIX'//')

	if [[ ${COMP_CWORD} -eq 1 ]]; then
		# First argument: complete with command options
		COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
		return 0
	fi

	local cmd="${COMP_WORDS[1]}"
	local position="${COMP_CWORD}"

  ( echo "cur: $cur" >> /tmp/slg_autocomplete.log ) 2> /dev/null
  ( echo "prev: $prev" >> /tmp/slg_autocomplete.log ) 2> /dev/null
  ( echo "cmd: $cmd" >> /tmp/slg_autocomplete.log ) 2> /dev/null
  # ( echo "postion: $position" >> /tmp/slg_autocomplete.log ) 2> /dev/null
  ( echo "COMP_WORDS: ${CMP_WORDS}" >> /tmp/slg_autocomplete.log ) 2> /dev/null
  # ( echo "Count positional args: $(_bash_toolkit_count_positional_args)" >> /tmp/slg_autocomplete.log ) 2> /dev/null

  if [[ "$cur" == -* && "$cur" != *=* ]]; then
    # Si existe un archivo $cmd_flags lo ejecuta para obtener una lista de available flags
    if [[ -f "${SCRIPTS_DIR}/autocomplete/${cmd}_flags" ]]; then
      ( echo "${cmd}_flags" >> /tmp/slg_autocomplete.log ) 2> /dev/null
      "${SCRIPTS_DIR}/autocomplete/${cmd}_flags" "${COMP_WORDS[@]:1}"
    fi
  elif [[ "$cur" =~ ^-([a-zA-Z0-9_-]+)= ]]; then
    flag="${cur#-}"  # Elimina el prefijo -
    flag="${flag#-}"  # Elimina el prefijo -- (el segundo -)
    flag="${flag%=}"  # Elimina el sufijo =
    # busca el script para autocompletar este comando, por ejemplo si estamos completando
    # command '--configuration'=<tab>, busca command_configuration que tiene que devolver los valores que
    # puede recibir
    if [[ -f "${SCRIPTS_DIR}/autocomplete/${cmd}_${flag}" ]]; then
      ( echo "${SCRIPTS_DIR}/autocomplete/${cmd}_${flag}" "${COMP_WORDS[@]:1}" >> /tmp/slg_autocomplete.log ) 2> /dev/null
      "${SCRIPTS_DIR}/autocomplete/${cmd}_${flag}" "${COMP_WORDS[@]:1}" | while IFS= read -r line; do
        echo "${cur}$line"
      done
    fi
  else
    local base_position=$(_bash_toolkit_count_positional_args)
    if [[ -f "${SCRIPTS_DIR}/autocomplete/${cmd}_${base_position}" ]]; then
      "${SCRIPTS_DIR}/autocomplete/${cmd}_${base_position}" "${COMP_WORDS[@]:1}"
    elif [[ -f "${SCRIPTS_DIR}/autocomplete/${cmd}" ]]; then
      "${SCRIPTS_DIR}/autocomplete/${cmd}" "${COMP_WORDS[@]:1}"
    else
      # if [[ "${cur}" = "" ]]; then
      #   ls
      # else
      #   ls "${cur}" | while IFS= read -r line; do
      #     echo "${cur}$line"
      #   done
      # fi
      ls -d1 ${cur}* 2> /dev/null
    fi
	fi
}

FUNCTION="
_${TOOLKIT_UNIQUE_SLUG}_autocomplete() {
  SLUG="$TOOLKIT_UNIQUE_SLUG"
  _bash_toolkit_autocomplete "\$@"
}"

eval $FUNCTION

# Register the slg_autocomplete function for commands
if [ ! -z "$TOOLKIT_ENTRY_POINT" ]; then
  if [ ! -e "$SCRIPTS_DIR/$TOOLKIT_ENTRY_POINT" ]; then
    # echo ln -sf "$TOOLKIT_DIR/entrypoint" "$SCRIPTS_DIR/$TOOLKIT_ENTRY_POINT"
    ln -sf "$TOOLKIT_DIR/entrypoint" "$SCRIPTS_DIR/$TOOLKIT_ENTRY_POINT"
  fi
  complete -F _${TOOLKIT_UNIQUE_SLUG}_autocomplete ${TOOLKIT_ENTRY_POINT}
fi

if [ ! -z "$TOOLKIT_ENTRY_POINT_2" ]; then
  if [ ! -e "$SCRIPTS_DIR/$TOOLKIT_ENTRY_POINT_2" ]; then
    # echo ln -sf "$TOOLKIT_DIR/entrypoint" "$SCRIPTS_DIR/$TOOLKIT_ENTRY_POINT_2"
    ln -sf "$TOOLKIT_DIR/entrypoint" "$SCRIPTS_DIR/$TOOLKIT_ENTRY_POINT_2"
  fi
  complete -F _${TOOLKIT_UNIQUE_SLUG}_autocomplete ${TOOLKIT_ENTRY_POINT_2}
fi

if [ ! -e "$SCRIPTS_DIR/toolkit" ]; then
  # echo ln -sf "$TOOLKIT_DIR" "$SCRIPTS_DIR/toolkit"
  ln -sf "$TOOLKIT_DIR" "$SCRIPTS_DIR/toolkit"
fi

export PATH=$PATH:$SCRIPTS_DIR

# Ensure the autocomplete function is loaded in  bash / zsh / fish / etc:
#
#   # slg-toolkit
#   source ~/bash-toolkit/toolkit/bootstrap ~/my_repos/slg-bash-toolkit/config
#
# The lines above are an example of how I install my personal toolkit in my machine.
# I reach out for my scripts with 's <tab>' or the more explicit 'slg <tab>' keystrokes.
# slg is the name I choose for my main repo of utils simply because SLG are my initials.
#
# The folder ~/my_repos/slg-bash-toolkit/ is where all my slg-* utility scripts live:
#
#   slg-start-all-services
#   slg-stop-all-services
#
# The folder ~/my_repos/slg-bash-toolkit/autocomplete is where autocomplete helpers live:
#
#   autocomplete/start-all-services_1  # provides options for the first positional argument
#   autocomplete/start-all-services_2  # provides options for the second positional argument
#   autocomplete/start-all-services_flags  # provides flags and available named arguments as options
#   autocomplete/start-all-services_container # provides options I can use with a named argument.
#                                             # In this case it will offer container names when I type
#                                             #     slg start-all-services --container=<tab>
#
# I also have other toolkits grouping utils for specific projects I work on:  'cn <tab>' 
#
#   # cn-toolkit
#   source ~/bash-toolkit/toolkit/bootstrap ~/my_repos/cuadernube-bash-toolkit/config
#
